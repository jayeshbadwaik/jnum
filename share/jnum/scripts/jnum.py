#!/usr/bin/env python3
import argparse
import json
import operator
import os
import pathlib
from collections import OrderedDict


def write_modification_warning(data, filestring):
    filestring = filestring + \
        "// Generated by enumeration.py. Do not modify this file manually.\n"
    return filestring


def write_opening_header_guard(data, filestring):
    filestring = filestring + "#ifndef " + data['header_guard']
    filestring = filestring + "\n"
    filestring = filestring + "#define " + data['header_guard']
    filestring = filestring + "\n"
    return filestring


def write_closing_header_guard(data, filestring):
    filestring = filestring + "#endif // " + data['header_guard']
    return filestring


def include_header_list(data, filestring):
    filestring = filestring + "#include <string_view>"
    filestring = filestring + "\n"
    filestring = filestring + "#include <array>"
    filestring = filestring + "\n"
    filestring = filestring + "#include <jnum/jnum.hpp>"
    filestring = filestring + "\n"
    return filestring


def open_main_namespace(data, filestring):
    filestring = filestring + "namespace " + data['namespace'] + " {"
    filestring = filestring + "\n"
    return filestring


def close_main_namespace(data, filestring):
    filestring = filestring + "} // namespace " + data['namespace']
    filestring = filestring + "\n"
    return filestring


def open_struct(data, filestring):
    filestring = filestring + "struct " + data['name'] + " { "
    filestring = filestring + "\n"
    return filestring


def register_as_jnum_type(data, filestring):
    filestring = filestring + "  // Registering as a jnum type"
    filestring = filestring + "\n"
    filestring = filestring + "  using is_jnum = std::true_type;"
    filestring = filestring + "\n"
    return filestring


def write_underlying_type(data, filestring):
    filestring = filestring + "  // Underlying Type"
    filestring = filestring + "\n"
    filestring = filestring + "  using underlying_type = " + \
        data['underlying_type'] + ";"
    filestring = filestring + "\n"
    return filestring


def write_identifier_string(data, filestring):
    filestring = filestring + "  // Identifier String"
    filestring = filestring + "\n"
    filestring = filestring + "  static constexpr std::string_view string = "
    filestring = filestring + "\"" + data['string'] + "\";"
    filestring = filestring + "\n"
    return filestring


def write_namespace_string(data, filestring):
    filestring = filestring + "  // Identifier String"
    filestring = filestring + "\n"
    filestring = filestring + "  static constexpr "
    filestring = filestring + "  std::string_view namespace_string = "
    filestring = filestring + "\"" + data['namespace'] + "\";"
    filestring = filestring + "\n"
    return filestring


def write_option_list_decl(data, filestring):
    filestring = filestring + "  // Option List Declaration"
    filestring = filestring + "\n"
    option_list = data['option_list']
    for option, value in option_list.items():
        filestring = filestring + "  static const " + data['name']
        filestring = filestring + " " + option + ";"
        filestring = filestring + "\n"
    return filestring


def write_option_array(data, filestring):
    filestring = filestring + "  // List of Possible Options"
    filestring = filestring + "\n"
    filestring = filestring + "  static const option_array_t option_array;"
    filestring = filestring + "\n"
    return filestring


def write_option_array_length(data, filestring):
    filestring = filestring + "  // Number of Options"
    filestring = filestring + "\n"
    filestring = filestring + "  static constexpr std::size_t noption = "
    filestring = filestring + str(len(data['option_list'])) + ";"
    filestring = filestring + "\n"
    return filestring


def write_option_array_type(data, filestring):
    filestring = filestring + "  // List of Possible Options"
    filestring = filestring + "\n"
    filestring = filestring + "  using option_array_t"
    filestring = filestring + "  = std::array<"+data['name']+",noption>;"
    filestring = filestring + "\n"
    return filestring


def write_option_string_array(data, filestring):
    filestring = filestring + "  // List of Strings of Possible Options"
    filestring = filestring + "\n"
    filestring = filestring + "  static constexpr auto option_string_array"
    filestring = filestring + "\n"
    filestring = filestring + "    = jnum::detail::make_array("
    filestring = filestring + "\n"
    option_list = data['option_list']
    for option, value in option_list.items():
        filestring = filestring + "      " + \
            "std::string_view(\"" + option + "\")" + ","
        filestring = filestring + "\n"
    filestring = filestring[:-2]
    filestring = filestring + "\n"
    filestring = filestring + "    );"
    filestring = filestring + "\n"
    return filestring


def write_enumeration(data, filestring):
    filestring = filestring + "  // Underlying Enumeration Class"
    filestring = filestring + "\n"
    filestring = filestring + "  enum class enum_type : underlying_type { "
    option_list = data['option_list']
    for option, value in option_list.items():
        filestring = filestring + option + " = " + value + ", "
    filestring = filestring[:-2]
    filestring = filestring + " };"
    filestring = filestring + "\n"
    return filestring


def write_state(data, filestring):
    filestring = filestring + "  // State of the Struct"
    filestring = filestring + "\n"
    filestring = filestring + \
        "  enum_type e_{enum_type::" + data['default_option'] + "};"
    filestring = filestring + "\n"
    return filestring


def write_public_default_constructor(data, filestring):
    filestring = filestring + "  // Default Constructor"
    filestring = filestring + "\n"
    filestring = filestring + "  constexpr " + data['name']
    filestring = filestring + "() = default;"
    filestring = filestring + "\n"
    return filestring


def write_private_constructor(data, filestring):
    filestring = filestring + "  // Private Constructor"
    filestring = filestring + "\n"
    filestring = filestring + "  constexpr " + data['name']
    filestring = filestring + "(enum_type const& e) : e_(e) {}"
    filestring = filestring + "\n"
    return filestring


def write_ut_conversion(data, filestring):
    filestring = filestring + "  // Converting to Underlying Type"
    filestring = filestring + "\n"
    filestring = filestring + "  constexpr"
    filestring = filestring + "  underlying_type underlying_value() "
    filestring = filestring + "  const "
    filestring = filestring + "{ return static_cast<underlying_type>(e_); }"
    filestring = filestring + "\n"
    return filestring


def write_implicit_conversion(data, filestring):
    filestring = filestring + "  // Implicit Conversion to Enumeration"
    filestring = filestring + "\n"
    filestring = filestring + "  constexpr operator enum_type() const "
    filestring = filestring + "{ return e_; }"
    filestring = filestring + "\n"
    return filestring


def switch_to_public(data, filestring):
    filestring = filestring + "public: "
    filestring = filestring + "\n"
    return filestring


def switch_to_private(data, filestring):
    filestring = filestring + "private: "
    filestring = filestring + "\n"
    return filestring


def close_struct(data, filestring):
    filestring = filestring + "}; "
    filestring = filestring + "\n"
    return filestring


def write_struct(data, filestring):
    filestring = open_struct(data, filestring)
    filestring = switch_to_public(data, filestring)
    filestring = write_underlying_type(data, filestring)
    filestring = filestring + "\n"
    filestring = write_enumeration(data, filestring)
    filestring = filestring + "\n"
    filestring = write_identifier_string(data, filestring)
    filestring = filestring + "\n"
    filestring = write_namespace_string(data, filestring)
    filestring = filestring + "\n"
    filestring = write_option_list_decl(data, filestring)
    filestring = filestring + "\n"
    filestring = write_option_array_length(data, filestring)
    filestring = filestring + "\n"
    filestring = write_option_array_type(data, filestring)
    filestring = filestring + "\n"
    filestring = write_option_array(data, filestring)
    filestring = filestring + "\n"
    filestring = write_option_string_array(data, filestring)
    filestring = filestring + "\n"
    filestring = write_public_default_constructor(data, filestring)
    filestring = filestring + "\n"
    filestring = switch_to_private(data, filestring)
    filestring = write_state(data, filestring)
    filestring = filestring + "\n"
    filestring = write_private_constructor(data, filestring)
    filestring = filestring + "\n"
    filestring = switch_to_public(data, filestring)
    filestring = write_ut_conversion(data, filestring)
    filestring = filestring + "\n"
    filestring = write_implicit_conversion(data, filestring)
    filestring = close_struct(data, filestring)
    return filestring


def write_option_array_def(data, filestring):
    filestring = filestring + "// List of Possible Options"
    filestring = filestring + "\n"
    filestring = filestring + "inline constexpr " + \
        data['name']+"::option_array_t "
    filestring = filestring + data['name'] + "::option_array"
    filestring = filestring + "\n"
    filestring = filestring + "   = jnum::detail::make_array("
    filestring = filestring + "\n"
    option_list = data['option_list']
    for option, value in option_list.items():
        filestring = filestring + "      " + \
            data['name'] + "(" + data['name'] + "::enum_type::" + option + "),"
        filestring = filestring + "\n"
    filestring = filestring[:-2]
    filestring = filestring + "\n"
    filestring = filestring + "    );"
    filestring = filestring + "\n"
    return filestring


def write_option_list_def(data, filestring):
    filestring = filestring + "// Option List Definition"
    filestring = filestring + "\n"
    option_list = data['option_list']
    for option, value in option_list.items():
        filestring = filestring + "inline constexpr " + data['name']
        filestring = filestring + " " + data['name'] + "::" + option
        filestring = filestring + "(enum_type::" + option + ");"
        filestring = filestring + "\n"
    return filestring


def open_aux_namespace(data, filestring):
    filestring = filestring + "namespace jnum {"
    filestring = filestring + "\n"
    return filestring


def close_aux_namespace(data, filestring):
    filestring = filestring + "} // namespace jnum"
    filestring = filestring + "\n"
    return filestring


def write_trait(data, filestring):
    filestring = filestring + "template<>"
    filestring = filestring + "\n"
    filestring = filestring + "struct is_jnum<"
    filestring = filestring + data['namespace'] + "::" + data['name']
    filestring = filestring + "> : std::true_type {"
    filestring = filestring + "\n"
    filestring = filestring + "};"
    filestring = filestring + "\n"
    return filestring


def sort_by_value(d):
    return OrderedDict(sorted(d.items(), key=lambda x: x[1]))


def generate_filestring(data):
    filestring = ""
    filestring = write_modification_warning(data, filestring)
    filestring = write_opening_header_guard(data, filestring)
    filestring = filestring + "\n"
    filestring = include_header_list(data, filestring)
    filestring = filestring + "\n"
    filestring = open_main_namespace(data, filestring)
    filestring = filestring + "\n"
    filestring = write_struct(data, filestring)
    filestring = filestring + "\n"
    filestring = write_option_array_def(data, filestring)
    filestring = filestring + "\n"
    filestring = write_option_list_def(data, filestring)
    filestring = close_main_namespace(data, filestring)
    filestring = filestring + "\n"
    filestring = open_aux_namespace(data, filestring)
    filestring = write_trait(data, filestring)
    filestring = close_aux_namespace(data, filestring)
    filestring = filestring + "\n"
    filestring = write_closing_header_guard(data, filestring)
    filestring = filestring + "\n"
    return filestring


def generate_cfo(file, relative_path):
    data = json.load(file)
    data['header_guard'] = relative_path.replace(
        '/', '_').replace('.', '_').upper()
    data['option_list'] = sort_by_value(data['option_list'])
    return generate_filestring(data)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="jnum generator")
    parser.add_argument("-i", "--input", help="Input File")
    parser.add_argument("-o", "--output", help="Output File")
    parser.add_argument("-r", "--relative", help="Relative Output File")

    cmdline = parser.parse_args()
    output_filename = cmdline.output
    input_filename = cmdline.input
    relative_path = cmdline.relative

    with open(input_filename, 'r') as infile:
        pathlib.Path(os.path.dirname(output_filename)).mkdir(
            parents=True, exist_ok=True)
        outfile = open(output_filename, "w+")
        outfile.write(generate_cfo(infile, relative_path))
